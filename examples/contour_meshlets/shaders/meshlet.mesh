#version 460
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_8bit_storage  : require
#extension GL_EXT_mesh_shader          : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_shader_draw_parameters: require
#extension GL_EXT_debug_printf : enable
#include "cpu_gpu_shared_config.h"
#include "glsl_helpers.glsl"
#include "mesh.glsl"

layout (constant_id = 0) const uint NUM_TASK_SHADER_INVOCATIONS = 1; // <- Expected to be set to 32 for Nvidia on host side.
layout (constant_id = 1) const uint NUM_MESH_SHADER_INVOCATIONS = 1; // <- Expected to be set to 32 for Nvidia on host side.
layout(local_size_x_id = 1, local_size_y = 1, local_size_z = 1) in;
// The max_vertices and max_primitives numbers have been recommended by Nvidia:
layout(lines, max_vertices = 64, max_primitives = 126) out;
//layout(triangles, max_vertices = 64, max_primitives = 126) out;

layout(push_constant) uniform PushConstants {
	bool mHighlightMeshlets;
	bool mCull;
	bool mContours;
	int  mVisibleMeshletIndexFrom;
	int  mVisibleMeshletIndexTo;  
} pushConstants;

layout(set = 0, binding = 1) uniform CameraTransform
{
	mat4 mViewProjMatrix;
	vec3 mCameraCenter;
} ubo;

taskPayloadSharedEXT uint meshletIndices[NUM_TASK_SHADER_INVOCATIONS];

layout(set = 1, binding = 1) buffer InstanceTransforms
{
	mat4 mat[];
} instanceMatrices;

layout(set = 2, binding = 0) buffer BoneMatrices 
{
	mat4 mat[]; // length of #bones
} boneMatrices[]; // length of #models

layout(set = 3, binding = 0) uniform  samplerBuffer positionBuffers[];
layout(set = 3, binding = 2) uniform  samplerBuffer normalBuffers[];
layout(set = 3, binding = 3) uniform  samplerBuffer texCoordsBuffers[];
#if USE_REDIRECTED_GPU_DATA
layout(std430, set = 3, binding = 4) buffer IndicesBuffer    { uint mIndices[];    } indicesBuffers[];
layout(std430, set = 3, binding = 4) buffer IndicesBuffer_u8 { uint8_t mIndices[]; } indicesBuffers_u8[];
#endif
layout(set = 3, binding = 5) uniform usamplerBuffer boneIndicesBuffers[];
layout(set = 3, binding = 6) uniform  samplerBuffer boneWeightsBuffers[];
layout(set = 4, binding = 0) buffer MeshletsBuffer { extended_meshlet mValues[]; } meshletsBuffer;
//-------------------------------------

//////////////////////////////////////////////////////////////////////
// Mesh shader output block:
layout (location = 0) out PerVertexData
{
	vec3 positionWS;
	vec3 normalWS;
	vec2 texCoord;
	flat int materialIndex;
	vec3 color;
} v_out[];   // [max_vertices]
  
// Color table for drawing each meshlet with a different color:
#define MAX_COLORS 64
vec3 meshletcolors[MAX_COLORS] = {
//  vec3(0.9, 0.1, 0.1), 
//  vec3(0.7, 0.2, 0.2), 
//  vec3(0.5, 0.3, 0.3), 
//  vec3(0.3, 0.4, 0.5), 
//  vec3(0.2, 0.5, 0.7), 
//  vec3(0.1, 0.7, 0.9), 
//  vec3(0.3, 0.6, 0.8), 
//  vec3(0.6, 0.8, 0.9), 
//  vec3(0.8, 0.9, 0.95),
//  vec3(1.0, 1.0, 1.0)  
vec3(228,137,142),
vec3(121,91,28),
vec3(125,91,152),
vec3(206,61,41),
vec3(93,103,156),
vec3(236,132,100),
vec3(153,70,146),
vec3(147,133,52),
vec3(147,70,84),
vec3(76,106,24),
vec3(80,94,37),
vec3(226,66,86),
vec3(102,139,224),
vec3(67,196,128),
vec3(182,177,70),
vec3(227,113,174),
vec3(174,51,111),
vec3(103,133,71),
vec3(69,132,185),
vec3(62,85,201),
vec3(132,127,73),
vec3(169,129,227),
vec3(50,114,59),
vec3(65,126,237),
vec3(160,77,202),
vec3(79,198,86),
vec3(109,83,184),
vec3(32,110,84),
vec3(165,117,71),
vec3(72,205,207),
vec3(83,153,91),
vec3(89,173,224),
vec3(101,100,19),
vec3(112,177,42),
vec3(224,179,65),
vec3(167,186,115),
vec3(117,112,236),
vec3(179,105,43),
vec3(218,168,114),
vec3(218,116,221),
vec3(110,191,146),
vec3(177,113,171),
vec3(113,85,167),
vec3(217,97,43),
vec3(204,63,165),
vec3(150,77,114),
vec3(229,65,129),
vec3(178,88,75),
vec3(149,71,35),
vec3(58,147,113),
vec3(217,150,210),
vec3(52,100,171),
vec3(141,74,170),
vec3(88,96,177),
vec3(181,139,42),
vec3(136,192,91),
vec3(174,189,46),
vec3(111,140,45),
vec3(226,143,48),
vec3(58,144,46),
vec3(205,95,123),
vec3(182,52,69),
vec3(46,165,155),
vec3(163,160,22)
};

uint hash(uint a)
{
   a = (a+0x7ed55d16) + (a<<12);
   a = (a^0xc761c23c) ^ (a>>19);
   a = (a+0x165667b1) + (a<<5);
   a = (a+0xd3a2646c) ^ (a<<9);
   a = (a+0xfd7046c5) + (a<<3);
   a = (a^0xb55a4f09) ^ (a>>16);
   return a;
}

shared vec3 vertexPos[64];

//////////////////////////////////////////////////////////////////////
// Mesh Shader Main:
void main() 
{
	uint meshletIndex = meshletIndices[2*gl_WorkGroupID.x];
	uint instanceId = meshletIndices[2*gl_WorkGroupID.x+1];
	uint mhash = hash(meshletIndex);
	vec3 mcolor = vec3(float(mhash & 255), float((mhash >> 8) & 255), float((mhash >> 16) & 255)) / 255.0;

	uint invocationId = gl_LocalInvocationID.x;

	// Get all the meshlet data:
	uint vertexCount          = uint(meshletsBuffer.mValues[meshletIndex].mGeometry.mVertexCount);
	uint edgeCount            = uint(meshletsBuffer.mValues[meshletIndex].mGeometry.mTriangleCount);
	uint materialIndex        = meshletsBuffer.mValues[meshletIndex].mMaterialIndex;
	mat4 transformationMatrix = meshletsBuffer.mValues[meshletIndex].mTransformationMatrix;

	uint modelIdx			  = meshletsBuffer.mValues[meshletIndex].mModelIndex;
	uint texelBufferIndex     = meshletsBuffer.mValues[meshletIndex].mTexelBufferIndex;
#if USE_REDIRECTED_GPU_DATA
	// Note: There is another set of indices contained in the indicesBuffers, which starts at an offset of vertexCount.
	//       For more details, see meshlet_helpers.hpp!
	uint indexOffset = uint(meshletsBuffer.mValues[meshletIndex].mGeometry.mDataOffset + vertexCount);
#endif
	
	bool animated =  meshletsBuffer.mValues[meshletIndex].mAnimated;

	vec3 center = meshletsBuffer.mValues[meshletIndex].center;
	float radius = meshletsBuffer.mValues[meshletIndex].radius;
	vec3 cone_axis = meshletsBuffer.mValues[meshletIndex].coneAxis;
	float cone_cutoff = meshletsBuffer.mValues[meshletIndex].coneCutoff;

	// Sets the actual output size of the primitives and vertices that the 
	// mesh shader workgroup will emit upon completion:
	SetMeshOutputsEXT(vertexCount, edgeCount);
	// ^ Note: This is the correct way and place to call SetMeshOutputsEXT, as the spec says:
	// 
	// > The arguments are taken from the first invocation in each workgroup. 
	// > Any invocation must execute this instruction no more than once and 
	// > under uniform control flow. There must not be any control flow path 
	// > to an output write that is not preceded by this instruction.


	// Step by NUM_MESH_SHADER_INVOCATIONS as we have that many threads but potentially more vertices to calculate:
	for (uint i = invocationId; i < vertexCount; i += NUM_MESH_SHADER_INVOCATIONS)
	{
		// Get the vertex index:
#if !USE_REDIRECTED_GPU_DATA
		uint vi = meshletsBuffer.mValues[meshletIndex].mGeometry.mVertices[i];
#else
		uint vi = uint(indicesBuffers[texelBufferIndex].mIndices[int(meshletsBuffer.mValues[meshletIndex].mGeometry.mDataOffset + i)]);
#endif
		// Get vertex data from the appropriate texel buffers and vertex indices:
		vec4 posMshSp = vec4(texelFetch(positionBuffers[texelBufferIndex], int(vi)).xyz, 1.0);
		vec3 nrmMshSp = texelFetch(normalBuffers[texelBufferIndex], int(vi)).xyz;
		vec4 boneWeights = texelFetch(boneWeightsBuffers[texelBufferIndex], int(vi));
		uvec4 boneIndices = texelFetch(boneIndicesBuffers[texelBufferIndex], int(vi));

		vec4 aniPos = posMshSp;
		vec3 aniNrm = nrmMshSp;
		
		if (animated) {
			// Do the bone transform for the position:
			aniPos = bone_transform(
				boneMatrices[modelIdx].mat[boneIndices[0]], 
				boneMatrices[modelIdx].mat[boneIndices[1]], 
				boneMatrices[modelIdx].mat[boneIndices[2]], 
				boneMatrices[modelIdx].mat[boneIndices[3]], 
				boneWeights, 
				posMshSp
			);
			// Do the bone transform for the normal:
			aniNrm = bone_transform(
				boneMatrices[modelIdx].mat[boneIndices[0]], 
				boneMatrices[modelIdx].mat[boneIndices[1]], 
				boneMatrices[modelIdx].mat[boneIndices[2]], 
				boneMatrices[modelIdx].mat[boneIndices[3]], 
				boneWeights, 
				nrmMshSp
			);
		}
		
		// Rest of the transformation:

		//vec4 posWS = transformationMatrix * vec4(center + radius * normalize(aniPos.xyz - center), 1); // project to bounding sphere
		//vec3 dir = (aniPos.xyz - center) - dot((aniPos.xyz - center), cone_axis) * cone_axis;
		//vec4 posWS = transformationMatrix * vec4(center + dir + cone_axis * length(dir) / tan(acos(cone_cutoff)) * 5 , 1); // project to bounding cone

		vec4 posWS = instanceMatrices.mat[instanceId] * transformationMatrix * aniPos;
		vertexPos[i] = posWS.xyz;
		vec4 posCS = ubo.mViewProjMatrix * posWS;
 
		// Set the vertex position:
		gl_MeshVerticesEXT[i].gl_Position = posCS;
 
		// Set the per vertex data for the fragment shader:
		v_out[i].positionWS = posWS.xyz;
		v_out[i].normalWS = mat3(instanceMatrices.mat[instanceId]) * mat3(transformationMatrix) * aniNrm;
		v_out[i].texCoord = texelFetch(texCoordsBuffers[texelBufferIndex], int(vi)).st;
		v_out[i].materialIndex = int(materialIndex);
		v_out[i].color = meshletcolors[meshletIndex % MAX_COLORS] / 255;
	}
 
	barrier();
 
	// Write the indices for the vertices:
	// Write for each triangle, also note the NUM_MESH_SHADER_INVOCATIONS stepping
	for (uint i = invocationId; i < edgeCount; i += NUM_MESH_SHADER_INVOCATIONS)
	{

		uint a, b, c, d;

#if !USE_REDIRECTED_GPU_DATA
		// Write the indices for the vertices:
//		gl_PrimitiveTriangleIndicesEXT[i] = uvec3(
//			meshletsBuffer.mValues[meshletIndex].mGeometry.mIndices[i * 3 + 0],
//			meshletsBuffer.mValues[meshletIndex].mGeometry.mIndices[i * 3 + 1],
//			meshletsBuffer.mValues[meshletIndex].mGeometry.mIndices[i * 3 + 2]
//		);
		
		a = uint(meshletsBuffer.mValues[meshletIndex].mGeometry.mIndices[i * 4]);
		b = uint(meshletsBuffer.mValues[meshletIndex].mGeometry.mIndices[i * 4 + 1]);
		c = uint(meshletsBuffer.mValues[meshletIndex].mGeometry.mIndices[i * 4 + 2]);
		d = uint(meshletsBuffer.mValues[meshletIndex].mGeometry.mIndices[i * 4 + 3]);
	
#else // USE_REDIRECTED_GPU_DATA
//		gl_PrimitiveTriangleIndicesEXT[i] = uvec3(
//			uint(indicesBuffers_u8[texelBufferIndex].mIndices[int(indexOffset*4 + i*3 + 0)]),
//			uint(indicesBuffers_u8[texelBufferIndex].mIndices[int(indexOffset*4 + i*3 + 1)]),
//			uint(indicesBuffers_u8[texelBufferIndex].mIndices[int(indexOffset*4 + i*3 + 2)])
//		);

		uint offset = indexOffset * 4 + i * 4;
		a = uint(indicesBuffers_u8[texelBufferIndex].mIndices[offset]);
		b = uint(indicesBuffers_u8[texelBufferIndex].mIndices[offset + 1]);
		c = uint(indicesBuffers_u8[texelBufferIndex].mIndices[offset + 2]);
		d = uint(indicesBuffers_u8[texelBufferIndex].mIndices[offset + 3]);
#endif
		gl_PrimitiveLineIndicesEXT[i] = uvec2(a, b);

		if (pushConstants.mContours) {

			vec3 vAPos = vertexPos[a], vBPos = vertexPos[b], vCPos = vertexPos[c], vDPos = vertexPos[d];

			vec3 fANormal = cross(vBPos - vAPos, vCPos - vAPos);
			vec3 fBNormal = cross(vAPos - vBPos, vDPos - vBPos);

			vec3 viewDir = (vBPos - ubo.mCameraCenter);

			bool fAOrient = (dot(viewDir, fANormal) > 0);
			bool fBOrient = (dot(viewDir, fBNormal) > 0);

			gl_MeshPrimitivesEXT[i].gl_CullPrimitiveEXT = (fAOrient == fBOrient) ;
		} else {
			gl_MeshPrimitivesEXT[i].gl_CullPrimitiveEXT = false;
		}
	}
}

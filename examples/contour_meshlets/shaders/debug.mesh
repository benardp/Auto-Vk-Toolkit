#version 460
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_8bit_storage  : require
#extension GL_EXT_mesh_shader          : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_shader_draw_parameters: require
#extension GL_EXT_debug_printf : enable
#include "cpu_gpu_shared_config.h"
#include "glsl_helpers.glsl"
#include "mesh.glsl"

layout (constant_id = 0) const uint NUM_TASK_SHADER_INVOCATIONS = 1; // <- Expected to be set to 32 for Nvidia on host side.
layout (constant_id = 1) const uint NUM_MESH_SHADER_INVOCATIONS = 1; // <- Expected to be set to 32 for Nvidia on host side.
layout(local_size_x_id = 1, local_size_y = 1, local_size_z = 1) in;
// The max_vertices and max_primitives numbers have been recommended by Nvidia:
layout(points, max_vertices = 64, max_primitives = 126) out;
//layout(lines, max_vertices = 64, max_primitives = 126) out;
//layout(triangles, max_vertices = 64, max_primitives = 126) out;

layout(push_constant) uniform PushConstants {
	bool mHighlightMeshlets;
	bool mCull;
	bool mContours;
	int  mVisibleMeshletIndexFrom;
	int  mVisibleMeshletIndexTo;  
} pushConstants;

layout(set = 0, binding = 1) uniform CameraTransform
{
	mat4 mViewProjMatrix;
	vec3 mCameraCenter;
} ubo;

taskPayloadSharedEXT uint meshletIndices[NUM_TASK_SHADER_INVOCATIONS];

layout(set = 2, binding = 0) buffer BoneMatrices 
{
	mat4 mat[]; // length of #bones
} boneMatrices[]; // length of #models

layout(set = 3, binding = 0) uniform  samplerBuffer positionBuffers[];
layout(set = 3, binding = 2) uniform  samplerBuffer normalBuffers[];
layout(set = 3, binding = 3) uniform  samplerBuffer texCoordsBuffers[];
#if USE_REDIRECTED_GPU_DATA
layout(std430, set = 3, binding = 4) buffer IndicesBuffer    { uint mIndices[];    } indicesBuffers[];
layout(std430, set = 3, binding = 4) buffer IndicesBuffer_u8 { uint8_t mIndices[]; } indicesBuffers_u8[];
#endif
layout(set = 3, binding = 5) uniform usamplerBuffer boneIndicesBuffers[];
layout(set = 3, binding = 6) uniform  samplerBuffer boneWeightsBuffers[];
layout(set = 4, binding = 0) buffer MeshletsBuffer { extended_meshlet mValues[]; } meshletsBuffer;
//-------------------------------------

//////////////////////////////////////////////////////////////////////
// Mesh shader output block:
layout (location = 0) out PerVertexData
{
	vec3 positionWS;
	vec3 normalWS;
	vec2 texCoord;
	flat int materialIndex;
	vec3 color;
} v_out[];   // [max_vertices]
  
// Color table for drawing each meshlet with a different color:
#define MAX_COLORS 10
vec3 meshletcolors[MAX_COLORS] = {
  vec3(0.9, 0.1, 0.1), 
  vec3(0.7, 0.2, 0.2), 
  vec3(0.5, 0.3, 0.3), 
  vec3(0.3, 0.4, 0.5), 
  vec3(0.2, 0.5, 0.7), 
  vec3(0.1, 0.7, 0.9), 
  vec3(0.3, 0.6, 0.8), 
  vec3(0.6, 0.8, 0.9), 
  vec3(0.8, 0.9, 0.95),
  vec3(1.0, 1.0, 1.0)  
};

uint hash(uint a)
{
   a = (a+0x7ed55d16) + (a<<12);
   a = (a^0xc761c23c) ^ (a>>19);
   a = (a+0x165667b1) + (a<<5);
   a = (a+0xd3a2646c) ^ (a<<9);
   a = (a+0xfd7046c5) + (a<<3);
   a = (a^0xb55a4f09) ^ (a>>16);
   return a;
}


//////////////////////////////////////////////////////////////////////
// Mesh Shader Main:
void main() 
{
	uint meshletIndex = meshletIndices[gl_WorkGroupID.x];
	uint mhash = hash(meshletIndex);
	vec3 mcolor = vec3(float(mhash & 255), float((mhash >> 8) & 255), float((mhash >> 16) & 255)) / 255.0;

	uint invocationId = gl_LocalInvocationID.x;

	// Get all the meshlet data:
	uint materialIndex        = meshletsBuffer.mValues[meshletIndex].mMaterialIndex;
	mat4 transformationMatrix = meshletsBuffer.mValues[meshletIndex].mTransformationMatrix;

	vec3 center = meshletsBuffer.mValues[meshletIndex].center;
	float radius = meshletsBuffer.mValues[meshletIndex].radius;
	vec3 cone_axis = meshletsBuffer.mValues[meshletIndex].coneAxis;
	float cone_cutoff = meshletsBuffer.mValues[meshletIndex].coneCutoff;


	// Sets the actual output size of the primitives and vertices that the 
	// mesh shader workgroup will emit upon completion:
	SetMeshOutputsEXT(64, 64);
	// ^ Note: This is the correct way and place to call SetMeshOutputsEXT, as the spec says:
	// 
	// > The arguments are taken from the first invocation in each workgroup. 
	// > Any invocation must execute this instruction no more than once and 
	// > under uniform control flow. There must not be any control flow path 
	// > to an output write that is not preceded by this instruction.

	float dn = 1.0 / float(64);
	float mc0 = 1.0 / sqrt(2.0);
	float mc1 = 1.0 / 1.533751168755204288118041;

	// Step by NUM_MESH_SHADER_INVOCATIONS as we have that many threads but potentially more vertices to calculate:
	for (uint i = invocationId; i < 64; i += NUM_MESH_SHADER_INVOCATIONS)
	{	
		// super-fibonacci sampling
		float s = i + 0.5;
		float t = s * dn;
		float d = 6.2831853072 * s;
		float r = sqrt(t);
		float R = sqrt(1 - t);
		float alpha = d * mc0;
		float beta = d * mc1;
		vec4 q = vec4(r * sin(alpha), r * cos(alpha), R * sin(beta), R * cos(beta));

		vec3 v = vec3(1,1,1);
		vec3 dir = v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
		
		vec4 posWS = transformationMatrix * vec4(center + radius * normalize(dir), 1);
		float phi = (float(i) / 64.0) * 6.2831853072;
		float l = (float(i % 8)/64) / cos(cone_cutoff);
		float y = tan(cone_cutoff) * float(i % 8)/64;
		float invLen = 1 / sqrt(cone_axis.x * cone_axis.x + cone_axis.z * cone_axis.z);
		vec3 c = vec3(cone_axis.z * invLen, 0, -cone_axis.x * invLen);
		vec3 b = cross(c, cone_axis);
		//posWS = transformationMatrix * vec4(center + (cone_axis * l + b * cos(phi) * y + c * sin(phi) * y) * 1, 1);
		vec4 posCS = ubo.mViewProjMatrix * posWS;
 
		// Set the vertex position:
		gl_MeshVerticesEXT[i].gl_Position = posCS;
 
		// Set the per vertex data for the fragment shader:
		v_out[i].positionWS = posWS.xyz;
		v_out[i].materialIndex = int(materialIndex);
		v_out[i].color = mcolor; //meshletcolors[meshletIndex % MAX_COLORS];

		gl_PrimitivePointIndicesEXT[i] = i;
	}
}

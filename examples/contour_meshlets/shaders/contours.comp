#version 460
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_8bit_storage  : require
#extension GL_EXT_nonuniform_qualifier : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_shader_draw_parameters: require
#extension GL_KHR_shader_subgroup_ballot: require
#extension GL_EXT_debug_printf : enable
#include "cpu_gpu_shared_config.h"
#include "glsl_helpers.glsl"
#include "mesh.glsl"

layout (constant_id = 0) const uint OCCUPANCY_PATCH = 1; // <- Expected to be set to 32 for Nvidia on host side.

layout(local_size_x_id=0,local_size_y=1,local_size_z=1) in;

struct DrawIndirectCommand {
    uint    indexCount;
    uint    instanceCount;
    uint    firstIndex;
    int     vertexOffset;
    uint    firstInstance;
};

layout(push_constant) uniform PushConstants {
	bool mHighlightMeshlets;
	bool mCull;
	bool mContours;
	int  mVisibleMeshletIndexFrom;
	int  mVisibleMeshletIndexTo;  
} pushConstants;

layout(set = 0, binding = 1) uniform CameraTransform
{
	mat4 mViewProjMatrix;
	vec3 mCameraCenter;
} ubo;

layout(set = 1, binding = 1) buffer InstanceTransforms
{
	mat4 mat[];
} instanceMatrices;

layout(set = 2, binding = 0) buffer BoneMatrices 
{
	mat4 mat[]; // length of #bones
} boneMatrices[]; // length of #models

layout(set = 3, binding = 0) uniform  samplerBuffer positionBuffers[];
layout(set = 3, binding = 2) uniform  samplerBuffer normalBuffers[];
layout(set = 3, binding = 3) uniform  samplerBuffer texCoordsBuffers[];
#if USE_REDIRECTED_GPU_DATA
layout(std430, set = 3, binding = 4) buffer IndicesBuffer    { uint mIndices[];    } indicesBuffers[];
layout(std430, set = 3, binding = 4) buffer IndicesBuffer_u8 { uint8_t mIndices[]; } indicesBuffers_u8[];
#endif
layout(set = 3, binding = 5) uniform usamplerBuffer boneIndicesBuffers[];
layout(set = 3, binding = 6) uniform  samplerBuffer boneWeightsBuffers[];
layout(set = 4, binding = 0) buffer MeshletsBuffer { extended_meshlet meshletsBuffer[]; } ;
//-------------------------------------

layout(set = 5, binding = 0) readonly buffer MeshletIndices { uint meshletIndices[ ]; };
layout(set = 6, binding = 0) buffer ContourIndices { uint contourIndices[ ]; };
layout(set = 6, binding = 1) buffer IndirectCommand { DrawIndirectCommand indirectCommand; };



shared vec3 vertexPos[64];
shared uint insertOffset;

//////////////////////////////////////////////////////////////////////
// Mesh Shader Main:
void main() 
{
	uint meshletIndex = meshletIndices[2*gl_WorkGroupID.x];
	uint instanceId = meshletIndices[2*gl_WorkGroupID.x+1];

	uint invocationId = gl_LocalInvocationID.x;

	// Get all the meshlet data:
	uint vertexCount          = uint(meshletsBuffer[meshletIndex].mGeometry.mVertexCount);
	uint edgeCount            = uint(meshletsBuffer[meshletIndex].mGeometry.mTriangleCount);
	uint materialIndex        = meshletsBuffer[meshletIndex].mMaterialIndex;
	mat4 transformationMatrix = meshletsBuffer[meshletIndex].mTransformationMatrix;

	uint modelIdx			  = meshletsBuffer[meshletIndex].mModelIndex;
	uint texelBufferIndex     = meshletsBuffer[meshletIndex].mTexelBufferIndex;
#if USE_REDIRECTED_GPU_DATA
	// Note: There is another set of indices contained in the indicesBuffers, which starts at an offset of vertexCount.
	//       For more details, see meshlet_helpers.hpp!
	uint indexOffset = uint(meshletsBuffer[meshletIndex].mGeometry.mDataOffset + vertexCount);
#endif
	
	bool animated =  meshletsBuffer[meshletIndex].mAnimated;

	// Step by OCCUPANCY_PATCH as we have that many threads but potentially more vertices to calculate:
	for (uint i = invocationId; i < vertexCount; i += OCCUPANCY_PATCH)
	{
		// Get the vertex index:
#if !USE_REDIRECTED_GPU_DATA
		uint vi = meshletsBuffer[meshletIndex].mGeometry.mVertices[i];
#else
		uint vi = uint(indicesBuffers[texelBufferIndex].mIndices[int(meshletsBuffer[meshletIndex].mGeometry.mDataOffset + i)]);
#endif
		// Get vertex data from the appropriate texel buffers and vertex indices:
		vec4 posMshSp = vec4(texelFetch(positionBuffers[texelBufferIndex], int(vi)).xyz, 1.0);
		vec3 nrmMshSp = texelFetch(normalBuffers[texelBufferIndex], int(vi)).xyz;
		vec4 boneWeights = texelFetch(boneWeightsBuffers[texelBufferIndex], int(vi));
		uvec4 boneIndices = texelFetch(boneIndicesBuffers[texelBufferIndex], int(vi));

		vec4 aniPos = posMshSp;
		vec3 aniNrm = nrmMshSp;
		
		if (animated) {
			// Do the bone transform for the position:
			aniPos = bone_transform(
				boneMatrices[modelIdx].mat[boneIndices[0]], 
				boneMatrices[modelIdx].mat[boneIndices[1]], 
				boneMatrices[modelIdx].mat[boneIndices[2]], 
				boneMatrices[modelIdx].mat[boneIndices[3]], 
				boneWeights, 
				posMshSp
			);
			// Do the bone transform for the normal:
			aniNrm = bone_transform(
				boneMatrices[modelIdx].mat[boneIndices[0]], 
				boneMatrices[modelIdx].mat[boneIndices[1]], 
				boneMatrices[modelIdx].mat[boneIndices[2]], 
				boneMatrices[modelIdx].mat[boneIndices[3]], 
				boneWeights, 
				nrmMshSp
			);
		}
		
		// Rest of the transformation:
		vec4 posWS = instanceMatrices.mat[instanceId] * transformationMatrix * aniPos;
		vertexPos[i] = posWS.xyz;
	}
 
	subgroupMemoryBarrierShared();
 
	// Write the indices for the vertices:
	// Write for each edge, also note the OCCUPANCY_PATCH stepping
	for (uint i = invocationId; i < edgeCount; i += OCCUPANCY_PATCH)
	{

		uint a, b, c, d;

#if !USE_REDIRECTED_GPU_DATA
		// Write the indices for the vertices:
		
		a = uint(meshletsBuffer[meshletIndex].mGeometry.mIndices[i * 4]);
		b = uint(meshletsBuffer[meshletIndex].mGeometry.mIndices[i * 4 + 1]);
		c = uint(meshletsBuffer[meshletIndex].mGeometry.mIndices[i * 4 + 2]);
		d = uint(meshletsBuffer[meshletIndex].mGeometry.mIndices[i * 4 + 3]);
	
#else // USE_REDIRECTED_GPU_DATA

		uint offset = indexOffset * 4 + i * 4;
		a = uint(indicesBuffers_u8[texelBufferIndex].mIndices[offset]);
		b = uint(indicesBuffers_u8[texelBufferIndex].mIndices[offset + 1]);
		c = uint(indicesBuffers_u8[texelBufferIndex].mIndices[offset + 2]);
		d = uint(indicesBuffers_u8[texelBufferIndex].mIndices[offset + 3]);
#endif

		bool visible = true;
		if (pushConstants.mContours) {

			vec3 vAPos = vertexPos[a], vBPos = vertexPos[b], vCPos = vertexPos[c], vDPos = vertexPos[d];

			vec3 fANormal = cross(vBPos - vAPos, vCPos - vAPos);
			vec3 fBNormal = cross(vAPos - vBPos, vDPos - vBPos);

			vec3 viewDir = (vBPos - ubo.mCameraCenter);

			bool fAOrient = (dot(viewDir, fANormal) > 0);
			bool fBOrient = (dot(viewDir, fBNormal) > 0);

			visible = (fAOrient != fBOrient) ;
		}


		uvec4 contourVisibleBallot = subgroupBallot(visible);

		if (invocationId == 0) {
			uint contourVisibleCount = subgroupBallotBitCount(contourVisibleBallot);
			insertOffset = atomicAdd(indirectCommand.indexCount, 2*contourVisibleCount);
		}

		subgroupMemoryBarrierShared();

		if(visible) {
			uint insertIndex = subgroupBallotExclusiveBitCount(contourVisibleBallot);
			contourIndices[insertOffset + 2*insertIndex]   = meshletsBuffer[meshletIndex].mGeometry.mVertices[a];
			contourIndices[insertOffset + 2*insertIndex+1] = meshletsBuffer[meshletIndex].mGeometry.mVertices[b];
		}
	}
}
